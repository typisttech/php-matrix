package main

import (
	"fmt"
	"os"
	"text/template"

	"github.com/typisttech/php-matrix/internal"
)

const eolTemplateRaw = `# DO NOT EDIT THIS FILE
# This file is generated by "internal/composer/success/main.go"
# Test the '{{ .Name }}' case

exec php-matrix composer {{ .Mode }}
cmp stdout stdout.golden
! stderr .

exec php-matrix composer {{ .Mode }} --source=auto
cmp stdout stdout.golden
! stderr .

exec php-matrix composer {{ .Mode }} --source=php.net
cmp stdout stdout.golden
! stderr .

exec php-matrix composer {{ .Mode }} --source=offline
cmp stdout stdout.golden
! stderr .

-- composer.json --
{"require":{"php":"{{ .Constraint }}"}}

-- stdout.golden --
`

const supportedTemplateRaw = `# DO NOT EDIT THIS FILE
# This file is generated by "internal/composer/success/main.go"
# Test the '{{ .Name }}' case

exec php-matrix composer {{ .Mode }}
stdout .
! stderr .

exec php-matrix composer {{ .Mode }} --source=auto
stdout .
! stderr .

exec php-matrix composer {{ .Mode }} --source=php.net
stdout .
! stderr .

exec php-matrix composer {{ .Mode }} --source=offline
stdout .
! stderr .

-- composer.json --
{"require":{"php":"{{ .Constraint }}"}}
`

var eolFileTemplate = template.Must(template.New("").Parse(eolTemplateRaw))
var supportedFileTemplate = template.Must(template.New("").Parse(supportedTemplateRaw))

type data struct {
	Mode         string
	Constraint   string
	fileTemplate *template.Template
}

func (d data) Name() string {
	return fmt.Sprintf("%q__%q", d.Mode, d.Constraint)
}

func (d data) Write(f *os.File) error {
	return d.fileTemplate.Execute(f, d)
}

func main() {
	num := len(internal.Modes) * (len(internal.EOLConstraints) + len(internal.SupportedConstraints))
	cases := make([]data, 0, num)

	for _, mode := range internal.Modes {
		for _, constraint := range internal.EOLConstraints {
			cases = append(cases, data{
				Mode:         mode,
				Constraint:   constraint,
				fileTemplate: eolFileTemplate,
			})
		}

		for _, constraint := range internal.SupportedConstraints {
			cases = append(cases, data{
				Mode:         mode,
				Constraint:   constraint,
				fileTemplate: supportedFileTemplate,
			})
		}
	}

	err := internal.Generate("composer/success", cases...)
	if err != nil {
		panic(err)
	}
}
